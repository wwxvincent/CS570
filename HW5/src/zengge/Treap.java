//  author: Xianduo Zeng


import java.util.Random;

/**
 * Implements a treap.
 *
 * @param <E> Comparable type.
 */
public class Treap<E extends Comparable<E>> {
    /**
     * Treap node class.
     *
     * @param <E> Comparable type.
     */
    private static class Node<E> {
        public E data; //key for search
        public int priority; //random heap priority
        public Node<E> left;
        public Node<E> right;

        /**
         * Creates a node with null pointers to child nodes.
         *
         * @param data     Data of the node
         * @param priority Priority of the node
         * @throws NullPointerException If data is null
         */
        public Node(E data, int priority) throws NullPointerException {
            if (data == null) {
                throw new NullPointerException();
            }
            this.data = data;
            this.priority = priority;
            this.left = null;
            this.right = null;
        }

        /**
         * Rotates the node to the right
         *
         * @return Node<E> The new root node
         */
        public Node<E> rotateRight() {
            Node<E> leftNode = this.left;
            this.left = leftNode.right;
            leftNode.right = this;
            // left node will be new root
            return leftNode;
        }

        /**
         * Rotates node to the left
         *
         * @return Node<E> The new root node
         */
        public Node<E> rotateLeft() {
            Node<E> rightNode = this.right;
            this.right = rightNode.left;
            rightNode.left = this;
            // right node will be new root
            return rightNode;
        }

        /**
         * Represent the data and priority of node as string
         * @return String  Node as string
         */
        @Override
        public String toString() {
            return "(key=" + this.data.toString() + ", priority=" + Integer.toString(this.priority) + ')';
        }
    }


    private Random priorityGenerator;    //Random priority generator
    private Node<E> root;                //Root of treap

    /**
     * Creates an empty treap.
     */
    public Treap() {
        root = null;
        priorityGenerator = new Random();
    }

    /**
     * Creates an empty treap and initializes priorityGenerator using new
     * Random(seed).
     *
     * @param seed
     */
    public Treap(long seed) {
        root = null;
        priorityGenerator = new Random(seed);
    }

    /**
     * Insert a new node with given element as its data and a random priority
     * generated by priorityGenerator.
     * Do nothing if key already exists
     *
     * @param key The data of the node
     * @return boolean    true if added
     */
    public boolean add(E key) {
        boolean isKeyExsit = find(key);
        if (isKeyExsit) {
            return false; // found key, do nothing
        } else {
            root = add(root, key, priorityGenerator.nextInt());
        }
        return true;
    }

    /**
     * Insert a new Node with given element and priority
     * Do nothing if key already exists
     *
     * @param key      data
     * @param priority priority
     * @return boolean    true if added
     */
    public boolean add(E key, int priority) {
        boolean isKeyExsit = find(key);
        if (isKeyExsit) {
            return false; // found key, do nothing
        } else {
            root = add(root, key, priority);
        }
        return true;
    }

    /**
     * Internal method to insert into a subtree.
     *
     * @param key         The item to insert.
     * @param subTreeRoot The node that roots the subtree.
     * @return The new root of the subtree.
     */
    private Node<E> add(Node<E> subTreeRoot, E key, int priority) {
        if (subTreeRoot == null) {
            Node<E> newNode = new Node<E>(key, priority);
            return newNode;
        }
        int compareResult = key.compareTo(subTreeRoot.data);
        if (compareResult < 0) {
            subTreeRoot.left = add(subTreeRoot.left, key, priority);
            if (subTreeRoot.priority < subTreeRoot.left.priority) {
                return subTreeRoot.rotateRight();
            }
        } else if (compareResult > 0) {
            subTreeRoot.right = add(subTreeRoot.right, key, priority);
            if (subTreeRoot.priority < subTreeRoot.right.priority) {
                return subTreeRoot.rotateLeft();
            }
        }
        return subTreeRoot;
    }

    /**
     * Deletes the node with the given key.
     * Do nothing if key not exits
     *
     * @param key Data of the node to be deleted
     * @return boolean    true if deleted
     */
    public boolean delete(E key) {
        boolean isKeyExists = find(key);
        if (isKeyExists)
            root = delete(root, key);
        return isKeyExists;
    }

    /**
     * Internal method to delete a key form a subtree.
     *
     * @param key         The item to be removed.
     * @param subTreeRoot The node that roots the subtree.
     * @return Node<E> The new root of the subtree.
     */
    private Node<E> delete(Node<E> subTreeRoot, E key) {
        if (subTreeRoot != null) {
            int compareResult = key.compareTo(subTreeRoot.data);
            if (compareResult > 0) {
                // key bigger than the root, delete at right
                subTreeRoot.right = delete(subTreeRoot.right, key);
            } else if (compareResult < 0) {
                // key smaller than the root, delete at left
                subTreeRoot.left = delete(subTreeRoot.left, key);
            } else { // found key
                if (subTreeRoot.left == null) {
                    return subTreeRoot.right;
                } else if (subTreeRoot.right == null) {
                    return subTreeRoot.left;
                } else {
                    // both children nodes are not null
                    Node<E> mostLeftNodeOfRightChild = subTreeRoot.right;
                    while (mostLeftNodeOfRightChild.left != null) {
                        mostLeftNodeOfRightChild = mostLeftNodeOfRightChild.left;
                    }
                    subTreeRoot.data = mostLeftNodeOfRightChild.data;
                    // delete the most left node from right child tree
                    subTreeRoot.right = delete(subTreeRoot.right, subTreeRoot.data);
                }
            }
        }
        return subTreeRoot;
    }

    /**
     * Finds the node with the given key
     * Returns true if found, false otherwise
     *
     * @param key Data of the node to be found
     * @return boolean    True if found, false otherwise
     */
    public boolean find(E key) {
        return find(root, key);
    }

    /**
     * Iteratively finds the node with the given key in the treap.
     * Returns the key if found, returns null if not found.
     *
     * @param key Data of the node to be found
     * @return boolean     True if found, false otherwise
     */
    private boolean find(Node<E> treeRoot, E key) {
        while (treeRoot != null) {
            int compareResult = key.compareTo(treeRoot.data);
            if (compareResult > 0) {
                treeRoot = treeRoot.right;
            } else if (compareResult < 0) {
                treeRoot = treeRoot.left;
            } else {
                // found key
                return true;
            }
        }
        return false;
    }

    /**
     * Serialize a treap to string
     *
     * @return String   Serialized treap string
     */
    public String toString() {
        return toString(root, 1);
    }

    /**
     * Internal method to serialize treap
     *
     * @param treeRoot The current root node
     * @param indent   The correct indent for each line
     * @return String  Treap as string
     */
    private String toString(Node<E> treeRoot, int indent) {
        StringBuilder output = new StringBuilder();
        for (int i = 0; i < indent; i++) {
            output.append("  ");
        }
        if (treeRoot == null) {
            output.append("null");
        } else {
            output.append(treeRoot.toString());
            output.append("\n");
            output.append(toString(treeRoot.left, indent + 1));
            output.append("\n");
            output.append(toString(treeRoot.right, indent + 1));
        }
        return output.toString();
    }

    public static void main(String[] args) {
        Treap<Integer> testTree = new Treap<Integer>();

        testTree.add(4, 19);
        testTree.add(2, 31);
        testTree.add(6, 70);
        testTree.add(1, 84);
        testTree.add(3, 12);
        testTree.add(5, 83);
        testTree.add(7, 26);

//		testTree.delete(6);

        System.out.println(testTree.toString());
    }
}
